import json
from pathlib import Path
from string import Template
import copy
from . import resources

AUTOCRAFT_NAMESPACE = 'dt.autocraft:'

ON_ADV_RECEIVE_TEMPLATE = Template('''
# $crafter
execute unless score #has_recipe dt.tmp matches 2 store success score #has_recipe dt.tmp run recipe take @s dt.autocraft:$crafter
execute unless score #has_recipe dt.tmp matches 2 if score #has_recipe dt.tmp matches 1 run data modify storage call_stack: this.name set value '{"text":"$item"}'
execute unless score #has_recipe dt.tmp matches 2 if score #has_recipe dt.tmp matches 1 run scoreboard players set #has_recipe dt.tmp 2
''')

ON_ADV_RECEIVE_START = '''
advancement revoke @s only dt.autocraft:autocrafter
scoreboard players set #has_recipe dt.tmp 0
scoreboard players set #num_loot dt.tmp 0
execute store result score #num_loot dt.tmp run clear @s minecraft:knowledge_book
'''
ON_ADV_RECEIVE_END = '''
#tellraw @a[distance=..5] [{"text":"has_Recipe: "},{"score":{"name":"#has_recipe","objective":"dt.tmp"}}]
#tellraw @a[distance=..5] [{"text":"loot: "},{"score":{"name":"#num_loot","objective":"dt.tmp"}}]
execute as @e[type=item,sort=nearest,limit=1,nbt={Item:{tag:{dt_autocrafter:1b}}}] store result entity @s Item.Count byte 1 run scoreboard players get #num_loot dt.tmp
'''
SET_RECIPE_TEMPLATE = Template('''
execute unless data storage call_stack: this.result[0] if data block ~ ~ ~ {CustomName:'{"text":"$item"}'} run data modify storage call_stack: this.result append from storage dt.crafting: recipes[{result:{id:"$item"}}]
execute if data storage call_stack: this.result[0] if data block ~ ~ ~ {CustomName:'{"text":"$item"}'} run execute store result score @s dt.tmp run execute if data storage dt.crafting: recipes[{result:{id:"$item"}}]''')

SET_RECIPE_START = '''# Generated by dthigpen/datapack-scripts/data-generation
function call_stack:push

data modify storage call_stack: this.recipe_name set from storage call_stack: this.arg0

data modify storage call_stack: this.result set value []
data modify storage call_stack: this.multiple_recipes set value false
'''
SET_RECIPE_END = '''
# TODO store separate list of recipes with duplicates for faster lookup
execute if score @s dt.tmp matches 2.. run data modify storage call_stack: call.arg0 set from storage dt.crafting: recipes
execute if score @s dt.tmp matches 2.. run data modify storage call_stack: call.arg1 set value {result:{id:""}}
execute if score @s dt.tmp matches 2.. run data modify storage call_stack: call.arg1.result.id set from storage call_stack: this.recipe_name
execute if score @s dt.tmp matches 2.. run function dt.array:api/split_by_key
execute if score @s dt.tmp matches 2.. run data modify storage call_stack: this.result append from storage call_stack: call.result[0]

#tellraw @p [{"text":"result: TODO store list of results that have multiple recipes"}]
#tellraw @p [{"text":"result: "},{"nbt":"this.result","storage":"call_stack:"}]
function call_stack:pop
'''

def __create_recipe_file(recipe_file_path: Path, recipe_dict: dict):
    with open(recipe_file_path, 'w') as crafter_file:
            json.dump(recipe_dict, crafter_file, indent=4)

def create_crafter_recipe_files(cutom_recipes_parent_dir: Path):
    recipe_suffix = '_crafter.json'
    crafter_dict_template = {
            "type": "minecraft:crafting_shapeless",
            "ingredients": [
                {
                    "item": "minecraft:crafting_table"
                },
                {
                    "item": "minecraft:dropper"
                }
            ],
            "result": {
                "item": "minecraft:knowledge_book"
            }
        }
    
    # Create recipe for base autocrafter
    __create_recipe_file(cutom_recipes_parent_dir / ('autocrafter.json'), copy.deepcopy(crafter_dict_template))
    # Create recipes for item specific autocrafters
    for result in resources.get_unique_result_recipes():
        crafter_dict = copy.deepcopy(crafter_dict_template)
        crafter_dict['ingredients'].append({'item':result})
        full_crafter_path = cutom_recipes_parent_dir / (result[result.find(':') + 1:] + recipe_suffix)
        __create_recipe_file(full_crafter_path, crafter_dict)
        

def create_autocrafter_advancement_file(adv_file_path: Path):
    #cog.msg('Writing autocrafter advancement file')
    autocrafter_advancements = {
        "criteria": {
            "autocrafter": {
                "trigger": "minecraft:recipe_unlocked",
                "conditions": {
                    "recipe": "dt.autocraft:autocrafter"
                }
            },
        },
        "requirements": [
        [
            "autocrafter"
        ]
      ],
    "rewards": {
        "function": "dt.autocraft:internal/blocks/autocrafter/setup/crafted_autocrafter"
    }
    }
    for result in resources.get_unique_result_recipes():
        crafter_name = result[result.find(':') + 1:] + '_crafter'
        autocrafter_advancements["requirements"][0].append(crafter_name)
        
        
        autocrafter_advancements['criteria'][crafter_name] = {
            "trigger": "minecraft:recipe_unlocked",
            "conditions": {
                "recipe": AUTOCRAFT_NAMESPACE + crafter_name
            }
        }
    with open(adv_file_path, 'w') as adv_file:
        json.dump(autocrafter_advancements, adv_file, indent=4, sort_keys=True)
    

def create_set_recipe_for_autocrafter_str():
    set_recipe_funct_content = ''
    for result in resources.get_unique_result_recipes():
        set_recipe_funct_content += SET_RECIPE_TEMPLATE.substitute({'item':result})
    return SET_RECIPE_START + set_recipe_funct_content + SET_RECIPE_END

def create_on_adv_granted_function_str():
    on_adv_funct_content = ''
    on_adv_funct_content += ON_ADV_RECEIVE_TEMPLATE.substitute({'crafter': 'autocrafter', 'item': 'Autocrafter'})
    for result in resources.get_unique_result_recipes():
        crafter_name = result[result.find(':') + 1:] + '_crafter'
        on_adv_funct_content += ON_ADV_RECEIVE_TEMPLATE.substitute({'crafter': crafter_name, 'item': result})
    
    return ON_ADV_RECEIVE_START + on_adv_funct_content + ON_ADV_RECEIVE_END